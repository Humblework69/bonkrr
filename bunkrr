#!/usr/bin/python3
"""Script to download media from bunkrr Album."""
import os
import sys
import asyncio
import aiohttp
from bs4 import BeautifulSoup
from tqdm import tqdm
from fake_useragent import UserAgent

DEFAULT_PARENT_FOLDER = 'downloads'  # Default folder name for downloaded media
MAX_CONCURRENT_DOWNLOADS = 16  # Maximum number of concurrent downloads


async def choices(prompt):
    """
    Prompt the user with a message and return based on their input.

    Args:
        prompt (str): The message to display to the user.

    Returns:
        None: If the user enters 'y'.
        None: If the user enters 'n' or leaves the input empty.

    Raises:
        SystemExit: If the user enters any other input.
    """
    i = input(prompt).strip().lower()
    if i == 'y':
        return
    if i == 'n' or not i:
        sys.exit(1)
    else:
        sys.exit(1)


def get_user_folder():
    """
    Prompts the user to enter an album folder name and returns the path of the folder.

    If the user enters a folder name, it is appended to the current working directory
    and the default parent folder.
    If the user leaves the input blank, the default parent folder is appended to
    the current working directory.

    Returns:
        str: The path of the album folder.
    """
    album_folder_input = input(
        "[?] Enter album folder name (or leave blank to use default): "
    ).strip()

    if album_folder_input.strip():
        album_folder = os.path.join(
            os.getcwd(),
            DEFAULT_PARENT_FOLDER,
            album_folder_input.strip())
    else:
        album_folder = os.path.join(os.getcwd(), DEFAULT_PARENT_FOLDER)

    print(f"[^] Download folder: {album_folder}")
    return album_folder


def get_random_user_agent():
    """
    Returns a random user agent string.

    :return: A random user agent string.
    """
    ua = UserAgent()
    return ua.random


async def fetch_image_data(session, base_url):
    """
    Fetches image data from a given base URL using an async session.

    Args:
        session (aiohttp.ClientSession): The async session used for making HTTP requests.
        base_url (str): The base URL to fetch image data from.

    Returns:
        list: A list of image data extracted from the HTML response.

    Raises:
        aiohttp.ClientResponseError: If there is an error in the HTTP response.

    """
    try:
        async with session.get(base_url) as response:
            response.raise_for_status()
            html = await response.text()

            soup = BeautifulSoup(html, 'html.parser')
            data = soup.find_all('div', class_='grid-images_box')
            if not data:
                print("[!] Failed to grab file URLs.")
                return None
    except aiohttp.ClientResponseError as e:
        print(f"[!] Error: {e}")
        return None

    return data


async def fetch_album_info(session, base_url):
    """
    Fetches album information from a given URL.

    Args:
        session (aiohttp.ClientSession): The aiohttp client session.
        base_url (str): The base URL to fetch the album information from.

    Returns:
        str: The name of the album if found, None otherwise.
    """
    try:
        async with session.get(base_url) as response:
            response.raise_for_status()
            html = await response.text()

            soup = BeautifulSoup(html, 'html.parser')
            album_info = soup.find('div', class_='mb-12-xxx')
            if album_info:
                album_name = album_info.find('h1').text.strip()
                return album_name
            else:
                return None
    except aiohttp.ClientResponseError as e:
        print(f"[!] Error: {e}")
        return None


async def create_download_folder(base_path, folder_name):
    """
    Create a download folder at the specified base path with the given folder name.

    Args:
        base_path (str): The base path where the download folder will be created.
        folder_name (str): The name of the download folder.

    Returns:
        str: The path of the created download folder.
    """
    path = os.path.join(base_path, folder_name)
    if not os.path.exists(path):
        os.makedirs(path)
    return path


async def download_media(session, url, path):
    """
    Downloads media from a given URL and saves it to the specified path.

    Args:
        session (aiohttp.ClientSession): The aiohttp client session.
        url (str): The URL of the media to download.
        path (str): The path where the downloaded media will be saved.

    Returns:
        bool: True if the media was successfully downloaded and saved, False otherwise.
    """
    file_path = os.path.join(path, os.path.basename(url))

    try:
        headers = {"User-Agent": get_random_user_agent()}
        async with session.get(url, headers=headers) as response:
            if response.status == 200:
                file_size = int(response.headers.get('content-length', 0))

                with open(file_path, "wb") as file, tqdm(
                    desc=os.path.basename(file_path),
                    total=file_size,
                    unit='B',
                    unit_scale=True,
                    unit_divisor=1024,
                    leave=False
                ) as progress_bar:
                    while True:
                        chunk = await response.content.read(1024)
                        if not chunk:
                            break
                        file.write(chunk)
                        progress_bar.update(len(chunk))

                return True
            return False
    except aiohttp.ClientError as e:
        print(f"[!] Failed to download '{file_path}': {e}")
        return False


async def download_images_from_urls(urls, album_folder):
    """
    Downloads images from a list of URLs asynchronously.

    Args:
        urls (list): A list of URLs of the images to be downloaded.
        album_folder (str): The folder where the downloaded images will be saved.

    Returns:
        tuple: A tuple containing two lists. The first list contains
        the URLs of the successfully downloaded images, and the second list contains
        the URLs of the images that failed to download.
    """
    async with aiohttp.ClientSession() as session:
        semaphore = asyncio.Semaphore(MAX_CONCURRENT_DOWNLOADS)

        async def download_media_wrapper(url):
            async with semaphore:
                return await download_media(session, url, album_folder)

        tasks = [download_media_wrapper(url) for url in urls]
        results = await asyncio.gather(*tasks)

        downloaded_files = [
            url for url, success in zip(
                urls, results) if success]
        failed_files = [
            url for url, success in zip(
                urls, results) if not success]

        return downloaded_files, failed_files


async def download_images():
    """
    Downloads images from bunkrr albums.

    This function prompts the user to enter bunkrr album
    URLs or provide a file path containing the URLs.
    It then downloads the images from the specified albums and saves them in separate folders.

    Returns:
        None
    """
    while True:
        urls = input(
            "[?] Enter bunkrr Album URLs (Support multiple URLs separated by comma)"
            " or provide a file path: "
        ).strip()
        if os.path.isfile(urls):
            with open(urls, 'r', encoding='utf-8') as file:
                urls = file.read().splitlines()
        else:
            urls = urls.split(',')
        urls = [url.strip() for url in urls]

        parent_folder = get_user_folder()
        count = 1
        downloaded_total = 0
        failed_total = 0

        for url in urls:
            async with aiohttp.ClientSession() as session:
                album_info = await fetch_album_info(session, url)
                if album_info:
                    print(f"\n[*] Downloading images from album: {album_info}")
                image_data = await fetch_image_data(session, url)
                if image_data is not None:
                    folder_name = str(count)
                    folder_path = await create_download_folder(parent_folder, folder_name)
                    download_urls = [
                        data.find('img')['src'].replace('/thumbs/', '/').rsplit('.', 1)[0] +
                        os.path.splitext(data.find('p').text.strip())[1] for data in image_data
                    ]
                    downloaded, failed = await download_images_from_urls(download_urls, folder_path)
                    downloaded_total += len(downloaded)
                    failed_total += len(failed)
                    count += 1

        downloaded_plural = 'file' if downloaded_total <= 1 else 'files'
        failed_plural = 'file' if failed_total <= 1 else 'files'

        print(f"\n[^] Downloaded: {downloaded_total} {downloaded_plural}, "
              f"Failed: {failed_total} {failed_plural}.")

        await choices("[?] Do you want to download again? (Y/N, default N): ")


async def main():
    """
    This is the main function of the program.
    It downloads images and prompts the user for a choice.
    """
    while True:
        while True:
            await download_images()
            await choices("[?] Do you want to download again? (Y/N, default N): ")


if __name__ == "__main__":
    asyncio.run(main())
