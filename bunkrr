#!/usr/bin/python3
"""Script to download media from bunkrr Album."""
import os
import sys
import asyncio
from validators import url as validate_url
import aiohttp
from bs4 import BeautifulSoup
from tqdm import tqdm
from fake_useragent import UserAgent

DEFAULT_PARENT_FOLDER = 'downloads' # Default folder name for downloaded media
MAX_CONCURRENT_DOWNLOADS = 16   # Maximum number of concurrent downloads


async def user_input(prompt):
    """
    Prompt the user for input and handle the response.

    Args:
        prompt (str): The prompt to display to the user.

    Returns:
        None

    Raises:
        SystemExit: If the user enters 'n' or an empty string.
    """
    i = input(prompt).strip().lower()
    if i == 'y':
        return
    if i == 'n' or not i:
        sys.exit(1)
    else:
        sys.exit(1)


def validate_input(func):
    """
    Decorator function that validates the input of a given function.

    Args:
        func: The function to be decorated.

    Returns:
        The decorated function.
    """
    def wrapper(*args, **kwargs):
        while True:
            try:
                return func(*args, **kwargs)
            except ValueError as ve:
                print(f"[!] Error: {ve}")
    return wrapper


@validate_input
def get_user_input():
    """
    Prompts the user to enter the bunkrr Album URL and album folder name.
    Validates the input and returns the base URL and album folder path.

    Raises:
        ValueError: If the bunkrr Album URL is empty or has an invalid format.

    Returns:
        tuple: A tuple containing the base URL and album folder path.
    """
    print("-----------------------------------------")
    base_url = input("[?] Enter bunkrr Album URL: ")
    if not base_url:
        raise ValueError("Bunkrr Album URL cannot be empty!")
    if not validate_url(base_url):
        raise ValueError("Invalid URL format! Please enter a valid URL.")
    album_folder_input = input("[?] Enter album folder name: ")

    if album_folder_input.strip():
        album_folder = os.path.join(
            os.getcwd(),
            DEFAULT_PARENT_FOLDER,
            album_folder_input.strip())
    else:
        album_folder = os.path.join(os.getcwd(), DEFAULT_PARENT_FOLDER)

    print(f"[^] Download folder: {album_folder}")
    print("-----------------------------------------")
    return base_url, album_folder


def get_random_user_agent():
    """
    Get a random User-Agent string.

    Returns:
        str: A randomly selected User-Agent string.
    """
    ua = UserAgent()
    return ua.random


async def fetch_image_data(session, base_url):
    """
    Fetches image data from a given base URL.

    Args:
        session: The aiohttp ClientSession object.
        base_url (str): The base URL to fetch image data from.

    Returns:
        list: A list of image data extracted from the HTML content.

    Raises:
        aiohttp.ClientResponseError: If there is an error while making the HTTP request.
    """
    try:
        async with session.get(base_url) as response:
            response.raise_for_status()
            html = await response.text()

            soup = BeautifulSoup(html, 'html.parser')
            data = soup.find_all('div', class_='grid-images_box')
            if not data:
                print("[!] Failed to grab file URLs.")
                return None
    except aiohttp.ClientResponseError as e:
        print(f"[!] Error: {e}")
        return None

    return data


def create_download_folder(base_path):
    """
    Create a download folder at the specified base path if it doesn't exist.

    Args:
        base_path (str): The base path where the download folder will be created.

    Returns:
        str: The path of the created download folder.
    """
    path = os.path.join(os.getcwd(), base_path)

    if not os.path.exists(path):
        os.makedirs(path)

    return path


async def download_media(session, url, path):
    """
    Downloads media from the given URL and saves it to the specified path.

    Args:
        session (aiohttp.ClientSession): The aiohttp client session.
        url (str): The URL of the media to download.
        path (str): The path where the downloaded media will be saved.

    Returns:
        bool: True if the media is successfully downloaded and saved, False otherwise.
    """
    file_path = os.path.join(path, os.path.basename(url))

    try:
        headers = {"User-Agent": get_random_user_agent()}
        async with session.get(url, headers=headers) as response:
            if response.status == 200:
                file_size = int(response.headers.get('content-length', 0))

                with open(file_path, "wb") as file, tqdm(
                    desc=os.path.basename(file_path),
                    total=file_size,
                    unit='B',
                    unit_scale=True,
                    unit_divisor=1024,
                    leave=False
                ) as progress_bar:
                    while True:
                        chunk = await response.content.read(1024)
                        if not chunk:
                            break
                        file.write(chunk)
                        progress_bar.update(len(chunk))

                return True
            return False
    except aiohttp.ClientError as e:
        print(f"[!] Failed to download '{file_path}': {e}")
        return False


async def download_images_from_urls(urls, album_folder,
                                    max_concurrent_downloads=MAX_CONCURRENT_DOWNLOADS):
    """
    Downloads images from a list of URLs asynchronously.

    Args:
        urls (list): A list of image URLs to download.
        album_folder (str): The folder where the downloaded images will be saved.
        max_concurrent_downloads (int): The maximum number of concurrent downloads.

    Returns:
        tuple: A tuple containing two lists - downloaded_files and failed_files.
            downloaded_files (list): A list of URLs that were successfully downloaded.
            failed_files (list): A list of URLs that failed to download.
    """
    async with aiohttp.ClientSession() as session:
        semaphore = asyncio.Semaphore(max_concurrent_downloads)

        async def download_media_wrapper(url):
            async with semaphore:
                return await download_media(session, url, album_folder)

        tasks = [download_media_wrapper(url) for url in urls]
        print(f"[+] Total file: {len(tasks)}")
        results = await asyncio.gather(*tasks)

        downloaded_files = [
            url for url, success in zip(
                urls, results) if success]
        failed_files = [
            url for url, success in zip(
                urls, results) if not success]

        downloaded_count = len(downloaded_files)
        failed_count = len(failed_files)

        downloaded_plural = 'file' if downloaded_count <= 1 else 'files'
        failed_plural = 'file' if failed_count <= 1 else 'files'

        print(f"\n[^] Downloaded: {downloaded_count} {downloaded_plural}, "
              f"Failed: {failed_count} {failed_plural}.")

    return downloaded_files, failed_files


async def download_images():
    """
    Downloads images from a given URL and saves them to a specified folder.

    Returns:
        None
    """
    while True:
        url, folder_name = get_user_input()
        async with aiohttp.ClientSession() as session:
            image_data = await fetch_image_data(session, url)
        if image_data is not None:
            break
        await user_input("[!] Error fetching data, Retry? (Y/N, default N): ")

    folder_path = create_download_folder(folder_name)
    download_urls = [data.find('img')['src'].replace('/thumbs/', '/').rsplit('.', 1)[0] +
                     os.path.splitext(data.find('p').text.strip())[1] for data in image_data]
    await download_images_from_urls(download_urls, folder_path, MAX_CONCURRENT_DOWNLOADS)


async def main():
    """
    This is the main function that controls the execution flow of the program.
    It continuously downloads images and prompts the user
    for input to determine if the download should be repeated.
    """
    while True:
        while True:
            await download_images()
            await user_input(
                "[?] Do you want to download again? (Y/N, default N): "
            )


if __name__ == "__main__":
    asyncio.run(main())
